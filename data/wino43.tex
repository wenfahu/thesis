
\section{F(4x4, 3x3, 6x6) 的实现}

最为常用的 F(4, 3) Winograd 卷积中的权重变换矩阵为

\begin{align}
\label{eq:winograd_f43}
  G = 
  \begin{pmatrix}
    \frac{1}{4} & 0 & 0 \\
    -\frac{1}{6} & -\frac{1}{6} & -\frac{1}{6} \\
    -\frac{1}{6} & \frac{1}{6} & -\frac{1}{6} \\
    \frac{1}{24} & \frac{1}{12} & \frac{1}{6} \\
    \frac{1}{24} & -\frac{1}{12} & \frac{1}{6} \\
    0 & 0 & 1
  \end{pmatrix}
\end{align}

将这个变换矩阵转变为整数矩阵需要对其乘24，而对于变换矩阵扩大24倍，将会对于计算带来相当的额外开销。
在执行Winograd 变换时，空间域的权重需要至少额外增加 $floor(\log_{2}{24^2}) = 10$ 位来表示其数值
以免数值溢出。此时如果输入的权重类型为8 位整数，则经过Winograd 变换之后，其数值表示则不得不由32位
整数作表示。而更大位长的数据表示则使得量化计算的效率大幅下降，量化参数的计算或者说定点数据（fixed 
point）的计算，的确在ARMv8-A 架构下会比同样位长的浮点数（floating point）计算更加高效，但这也是在
两者的数据位长相同的情形下，即 int32 的数据计算会比 float32 的计算高效，而如果整数运算需要更长的数据
表示，则整数计算在大多情况下会需要比同它数据表示位长更短的浮点计算效率低。这也就要求在实现量化计算的
过程中，使用整数运算实现原有的算法时，不仅要适度的对参与计算的数据类型作以调整，使用更高精度的数据表示
存储计算的结果，以避免计算的溢出，另外一方面，同时也要保证数据的表示不可以超过浮点运算中最为常用的
数据表示位长，即32位。否则，计算过程的吞吐量则会低于作为对照的浮点运算，这也是违背量化方法实现计算
加速的初衷的。

因此，在这里考虑到数据精度的表示对于计算效率的影响下，这一最为常用的 $F（4， 3）$ Winograd卷积算法
是不可以应用于整数实现的Winograd 卷积计算的。Winograd卷积算法的具体形式的导出，往往是限制在有理数
范围的，这也使得Winograd 卷积算法同FFT 卷积算法相比省去了复数乘法带来的额外开销。然而在有理数域的
数值计算特性也使得常用的Winograd卷积算法在整数计算场景只限于应用于加速效果相对有限的 $F(2, 3)$ 卷积。

而如果考虑到Winograd变换在复数域中可能的取值，则这一问题存在着相对较为简单的表示。尽管在复数域导出
Winograd 算法的动机看似是有点不合理的，毕竟在前文中也提到了Winograd 卷积同基于DFT 的卷积实现的联系，
以及Winograd 卷积相对DFT卷积的优势。Winograd 卷积从效果上来看，可以看作全实数表示的DFT卷积，Winograd
卷积在卷积尺度较小的场景下相对于DFT卷积的优势也正是来自于实数乘法的复杂度低于复数乘法。因此，在Winograd
算法中引入复数，看上去是一个在效率上有所倒退的举动。但实际上，这里的出发点在于获得更加简单的变换矩阵
表示，从而在引入可接受的运算开销的前提下实现量化计算。

最为常用的Winograd $F(4, 3)$ 卷积的形式\ref{eq:winograd_f43}是由 $ [0, 1, -1, 2, -1]$ 五个插值点导出的，
而如果使用对称且相对简单的复数插值点 $[0, 1, -1, i, -i]$，则会导出如下所示的实现F(4,3） 的变换矩阵。

\begin{align}
  B^T = 
  \begin{pmatrix}
    1 & 0 & 0 & 0 -1 & 0 \\
    0 & 1 & 1 & 1 & 1 & 0\\
    0 & -1 & 1 & -1 & 1 & 0 \\
    0 & -i & -1 & i & 1 & 0 \\
    0 & i & -1 & -i & 1 & 0 \\
    0 & -1 & 0 & 0 & 0 & 1
  \end{pmatrix}
\end{align}

\begin{align}
G = 
\begin{pmatrix}
  1 & 0 & 0 \\
  \frac{1}{4} & \frac{1}{4} & \frac{1}{4} \\
  \frac{1}{4} & -\frac{1}{4} & \frac{1}{4} \\
  \frac{1}{4} & \frac{i}{4} & -\frac{1}{4} \\
  \frac{1}{4} & -\frac{i}{4} & -\frac{1}{4} \\
  0 & 0 & 1 \\
\end{pmatrix}
\end{align}

\begin{align}
  A^T = 
  \begin{pmatrix}
    1 & 1 & 1 & 1 &1 &0\\ 
    0 & 1 & −1 & i & −i & 0\\
    0 & 1 & 1 & −1 & −1 & 0\\
    0 & 1 & −1 & −i & i & 1
  \end{pmatrix}
\end{align}

这里导出的变换矩阵使得参与计算的数值的尺度大幅下降，其中输入变换$B^T$ 和 输出变换 $A^T$中均只存在复数加减法，
而权重变换$G$中，数值中最大的分母也由24 减小为4。因此，权重变换在转化为整数运算的过程中，也只需要在原本的数据
表示上乘 $4^2$，而所需的额外的数据表示的位长则为 $\log_{2}(4^2) = 4$ 位。所以，在输入的权重的数据类型位8位整数
的场景下，仍然可以使用 16 位整数表示变换后的结果，而在计算最为密集的矩阵乘法部分也可以实现16位整数的矩阵乘法，
保证这一计算瓶颈的高吞吐。

以下将展开在这一变换表示下的计算复杂度相对于基于GEMM方法的卷积算法的优化。

由于这一方法所导出的各个变换矩阵所有的相似性，这里以输入变换为例说明，其他变换过程均与此过程类似。

\begin{align}
  B^T = 
  \begin{pmatrix}
    1 & 0 & 0 & 0 -1 & 0 \\
    0 & 1 & 1 & 1 & 1 & 0\\
    0 & -1 & 1 & -1 & 1 & 0 \\
    0 & -i & -1 & i & 1 & 0 \\
    0 & i & -1 & -i & 1 & 0 \\
    0 & -1 & 0 & 0 & 0 & 1
  \end{pmatrix}
\end{align}

在上面的变换矩阵中的参数的特殊形式以及矩阵乘法的线性可组合性可知，在输入变换$ B^TdB$ 的计算过程中，第一步计算
$B^Td $ 的结果，对应的第五行和第四行是一对共轭复数。或者这里更加直观的将$B^T d$ 的结果展开：

\begin{align}
  d^*[0, j] = d_{0, j} + d_{4, j}
  d^*[1, j] = d_{1, j} + d_{2, j} + d_{3, j} + d_{4, j}
  d^*[2, j] = -d_{1, j} + d_{2, j} - d_{3, j} + d_{4, j}
  d^*[3, j] = -d_{2, j} + d_{4, j} - i(d_{1, j} - d_{3, j})
  d^*[4, j] = -d_{2, j} + d_{4, j} + i(d_{1, j} - d_{3, j})
  d^*[5, j] = -d_{1, j} + d_{5, j}
\end{align}

而更进一步的，按照前面所述的计算这一变换的实现 $D = B^TdB = (B^T(B^T d)^T)^T$，对上述计算结果转置之后再做同样
的处理之后再做转置，可知变换之后的矩阵，其第四行与第五行的元素，第四列与第五列的元素，分别对应的构成共轭复数。
